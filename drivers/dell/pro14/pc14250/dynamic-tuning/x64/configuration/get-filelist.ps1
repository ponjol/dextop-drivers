#IF YA WANNA USE DIS, PLACE IT IN THE NECESSARY FOLDER AND RUN
#IT'LL OUTPUT THE FILE LIST TO A TXT FILE (PLS WORK)


<#
.SYNOPSIS
  Generate files.txt for driver deployment (Intune/Autopilot).

.DESCRIPTION
  Runs from inside a driver category folder (e.g., bluetooth, wifi, audio).
  Recursively enumerates driver files and writes relative paths to files.txt.
  Default extensions: .inf, .cat, .sys, .dll, .exe, .bin, .dat

.PARAMETER Root
  Optional. Path to scan. Defaults to current directory.

.PARAMETER IncludeOptional
  Include optional non-INF/CAT/SYS files (DLL/EXE/BIN/DAT). Default: $true

.PARAMETER Extensions
  Custom list of extensions to include. Overrides defaults when supplied.

.PARAMETER Append
  Append to existing files.txt instead of overwriting. Default: $false

.PARAMETER DryRun
  Show what would be written without modifying files.txt.

.EXAMPLE
  # Run in current folder and generate files.txt:
  .\New-FilesList.ps1

.EXAMPLE
  # Explicit folder, only INF/CAT/SYS:
  .\New-FilesList.ps1 -Root "C:\Repo\drivers\dell\pro14\pc14250\bluetooth" -IncludeOptional:$false

.EXAMPLE
  # Custom extensions:
  .\New-FilesList.ps1 -Extensions ".inf",".cat",".sys",".dll",".mui"
#>

[CmdletBinding()]
param(
  [string]$Root = (Get-Location).Path,
  [bool]$IncludeOptional = $true,
  [string[]]$Extensions,
  [bool]$Append = $false,
  [switch]$DryRun
)

# Defaults if not provided
if (-not $Extensions -or $Extensions.Count -eq 0) {
  $Extensions = @(".inf", ".cat", ".sys")
  if ($IncludeOptional) {
    $Extensions += @(".dll", ".exe", ".bin", ".dat")
  }
}

# Normalize and ensure dot-prefix on extensions
$Extensions = $Extensions | ForEach-Object {
  $e = $_.ToLower().Trim()
  if ($e -notmatch '^\.') { ".$e" } else { $e }
} | Sort-Object -Unique

Write-Verbose "Scanning root: $Root"
Write-Verbose "Extensions: $($Extensions -join ', ')"

# Compute relative path helper
function Get-RelativePath {
  param([string]$Base,[string]$Full)
  $uriBase = (Resolve-Path -LiteralPath $Base).Path
  $uriBase = [System.IO.Path]::GetFullPath($uriBase)
  $uriA = New-Object System.Uri($uriBase + [System.IO.Path]::DirectorySeparatorChar)
  $uriB = New-Object System.Uri((Resolve-Path -LiteralPath $Full).Path)
  $rel = $uriA.MakeRelativeUri($uriB).ToString()
  # Convert URI-style / to Windows path separator neutral form
  return $rel -replace '/', '/'
}

# Enumerate files
$all = Get-ChildItem -Path $Root -Recurse -File -ErrorAction Stop |
  Where-Object { $Extensions -contains $_.Extension.ToLower() }

# Sort: folder path first, then file name
$sorted = $all | Sort-Object @{Expression = { $_.DirectoryName }}, @{Expression = { $_.Name }}

# Build relative paths
$relPaths = foreach ($f in $sorted) {
  Get-RelativePath -Base $Root -Full $f.FullName
}

# Target files.txt path
$filesTxt = Join-Path -Path $Root -ChildPath "files.txt"

# Output block
if ($DryRun) {
  Write-Host "Dry run: would write files.txt at: $filesTxt"
  $relPaths | ForEach-Object { Write-Host $_ }
} else {
  if ($Append -and (Test-Path -LiteralPath $filesTxt)) {
    # Append mode
    Add-Content -Path $filesTxt -Value ($relPaths -join [Environment]::NewLine)
  } else {
    # Overwrite mode with header
    $header = @(
      "# Auto-generated by New-FilesList.ps1 on $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')",
      "# Root: $Root",
      "# Included extensions: $($Extensions -join ', ')",
      "# Lines below are relative paths used by the Intune script to download/install drivers.",
      ""
    )
    Set-Content -Path $filesTxt -Value ($header -join [Environment]::NewLine)
    Add-Content -Path $filesTxt -Value ($relPaths -join [Environment]::NewLine)
  }
  Write-Host "files.txt written: $filesTxt"
  Write-Host "Count: $($relPaths.Count) entries"
}

# Optional: quick validation tips
Write-Host "`nTips:"
Write-Host " - Ensure each INF's referenced files (SourceDisksFiles/CopyFiles) exist in the same folder."
Write-Host " - Keep each driver (INF+CAT+SYS+others) together inside a subfolder for clarity."
Write-Host " - The order in files.txt doesn't matter; we sort for readability."
